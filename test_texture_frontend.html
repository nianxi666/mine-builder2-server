<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æè´¨åŒ…åŠŸèƒ½æµ‹è¯•</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #00ff00; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #333; background: #222; }
        .success { color: #00ff00; }
        .error { color: #ff0000; }
        .warning { color: #ffaa00; }
        pre { background: #111; padding: 10px; overflow-x: auto; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
    </style>
</head>
<body>
    <h1>ğŸ¨ æè´¨åŒ…åŠŸèƒ½æµ‹è¯•</h1>
    
    <div class="test-section">
        <h2>1ï¸âƒ£ æµ‹è¯•APIå“åº”</h2>
        <button onclick="testApiResponse()">è¿è¡Œæµ‹è¯•</button>
        <pre id="api-test-result">ç­‰å¾…æµ‹è¯•...</pre>
    </div>
    
    <div class="test-section">
        <h2>2ï¸âƒ£  æµ‹è¯•Base64è§£ç </h2>
        <button onclick="testBase64Decode()">è¿è¡Œæµ‹è¯•</button>
        <pre id="decode-test-result">ç­‰å¾…æµ‹è¯•...</pre>
    </div>
    
    <div class="test-section">
        <h2>3ï¸âƒ£ æµ‹è¯•JSZipåŠ è½½</h2>
        <button onclick="testJSZipLoad()">è¿è¡Œæµ‹è¯•</button>
        <pre id="jszip-test-result">ç­‰å¾…æµ‹è¯•...</pre>
    </div>
    
    <div class="test-section">
        <h2>4ï¸âƒ£ å®Œæ•´æµç¨‹æµ‹è¯•</h2>
        <button onclick="testFullProcess()">è¿è¡Œå®Œæ•´æµ‹è¯•</button>
        <pre id="full-test-result">ç­‰å¾…æµ‹è¯•...</pre>
    </div>

    <script>
        let apiData = null;
        
        async function testApiResponse() {
            const output = document.getElementById('api-test-result');
            output.innerHTML = 'æ­£åœ¨æµ‹è¯•...\n';
            
            try {
                const response = await fetch('/api/files');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                apiData = data;
                
                let result = '<span class="success">âœ… APIå“åº”æ­£å¸¸</span>\n\n';
                result += `å“åº”æ•°æ®:\n`;
                result += `- åŒ…å«model: ${!!data.model}\n`;
                result += `- åŒ…å«texture: ${!!data.texture}\n`;
                result += `- åŒ…å«reference: ${!!data.reference}\n\n`;
                
                if (data.texture) {
                    result += `æè´¨åŒ…ä¿¡æ¯:\n`;
                    result += `- åç§°: ${data.texture.name}\n`;
                    result += `- MIMEç±»å‹: ${data.texture.mimeType}\n`;
                    result += `- æ•°æ®é•¿åº¦: ${data.texture.data.length.toLocaleString()} å­—ç¬¦\n`;
                    result += `- é¢„ä¼°å¤§å°: ${Math.round(data.texture.data.length * 3 / 4).toLocaleString()} å­—èŠ‚\n`;
                    result += '<span class="success">âœ… æè´¨åŒ…æ•°æ®å®Œæ•´</span>\n';
                } else {
                    result += '<span class="error">âŒ æœªæ‰¾åˆ°æè´¨åŒ…æ•°æ®</span>\n';
                }
                
                output.innerHTML = result;
            } catch (error) {
                output.innerHTML = `<span class="error">âŒ é”™è¯¯: ${error.message}</span>`;
            }
        }
        
        async function testBase64Decode() {
            const output = document.getElementById('decode-test-result');
            output.innerHTML = 'æ­£åœ¨æµ‹è¯•...\n';
            
            if (!apiData || !apiData.texture) {
                output.innerHTML = '<span class="warning">âš ï¸ è¯·å…ˆè¿è¡ŒAPIæµ‹è¯•</span>';
                return;
            }
            
            try {
                const base64Data = apiData.texture.data;
                const mimeType = apiData.texture.mimeType;
                
                // æ–¹æ³•1: ä½¿ç”¨fetch + data URL
                const response = await fetch(`data:${mimeType};base64,${base64Data}`);
                const arrayBuffer = await response.arrayBuffer();
                
                let result = '<span class="success">âœ… Base64è§£ç æˆåŠŸ</span>\n\n';
                result += `è§£ç ç»“æœ:\n`;
                result += `- ArrayBufferå¤§å°: ${arrayBuffer.byteLength.toLocaleString()} å­—èŠ‚\n`;
                result += `- ç±»å‹: ${arrayBuffer.constructor.name}\n`;
                
                // æ£€æŸ¥ZIPç­¾å
                const uint8 = new Uint8Array(arrayBuffer);
                const signature = Array.from(uint8.slice(0, 4))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join(' ');
                result += `- ZIPç­¾å: ${signature}\n`;
                
                if (uint8[0] === 0x50 && uint8[1] === 0x4B) {
                    result += '<span class="success">âœ… ZIPæ–‡ä»¶ç­¾åæ­£ç¡® (PK)</span>\n';
                } else {
                    result += '<span class="error">âŒ ZIPæ–‡ä»¶ç­¾åé”™è¯¯</span>\n';
                }
                
                output.innerHTML = result;
            } catch (error) {
                output.innerHTML = `<span class="error">âŒ é”™è¯¯: ${error.message}</span>`;
            }
        }
        
        async function testJSZipLoad() {
            const output = document.getElementById('jszip-test-result');
            output.innerHTML = 'æ­£åœ¨æµ‹è¯•...\n';
            
            if (typeof JSZip === 'undefined') {
                output.innerHTML = '<span class="error">âŒ JSZipæœªåŠ è½½</span>';
                return;
            }
            
            if (!apiData || !apiData.texture) {
                output.innerHTML = '<span class="warning">âš ï¸ è¯·å…ˆè¿è¡ŒAPIæµ‹è¯•</span>';
                return;
            }
            
            try {
                const base64Data = apiData.texture.data;
                const mimeType = apiData.texture.mimeType;
                
                // è§£ç 
                const response = await fetch(`data:${mimeType};base64,${base64Data}`);
                const arrayBuffer = await response.arrayBuffer();
                
                // åŠ è½½ZIP
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // æŸ¥æ‰¾æè´¨æ–‡ä»¶
                const texturePathPrefix = 'assets/minecraft/textures/blocks/';
                const textureFiles = [];
                
                zip.forEach((relativePath, zipEntry) => {
                    if (relativePath.startsWith(texturePathPrefix) && 
                        relativePath.toLowerCase().endsWith('.png') && 
                        !zipEntry.dir) {
                        const textureName = relativePath.substring(texturePathPrefix.length)
                            .replace(/\\.png$/i, '');
                        if (textureName) {
                            textureFiles.push(textureName);
                        }
                    }
                });
                
                let result = '<span class="success">âœ… JSZipåŠ è½½æˆåŠŸ</span>\n\n';
                result += `ZIPå†…å®¹:\n`;
                result += `- æ€»æ–‡ä»¶æ•°: ${Object.keys(zip.files).length}\n`;
                result += `- æè´¨æ–‡ä»¶æ•°: ${textureFiles.length}\n\n`;
                
                result += `å‰10ä¸ªæè´¨:\n`;
                textureFiles.slice(0, 10).forEach((name, i) => {
                    result += `  ${i + 1}. ${name}\n`;
                });
                
                if (textureFiles.length > 10) {
                    result += `  ... è¿˜æœ‰ ${textureFiles.length - 10} ä¸ª\n`;
                }
                
                result += '\n<span class="success">âœ… æè´¨åŒ…ç»“æ„æ­£ç¡®</span>\n';
                
                output.innerHTML = result;
            } catch (error) {
                output.innerHTML = `<span class="error">âŒ é”™è¯¯: ${error.message}\n${error.stack}</span>`;
            }
        }
        
        async function testFullProcess() {
            const output = document.getElementById('full-test-result');
            output.innerHTML = 'æ­£åœ¨è¿è¡Œå®Œæ•´æµ‹è¯•...\n\n';
            
            try {
                // Step 1: API
                output.innerHTML += '1ï¸âƒ£ è·å–APIæ•°æ®...\n';
                const response = await fetch('/api/files');
                const data = await response.json();
                
                if (!data.texture) {
                    throw new Error('APIæœªè¿”å›æè´¨åŒ…');
                }
                output.innerHTML += '<span class="success">âœ… APIæ•°æ®è·å–æˆåŠŸ</span>\n\n';
                
                // Step 2: Decode
                output.innerHTML += '2ï¸âƒ£ è§£ç Base64...\n';
                const arrayBuffer = await fetch(`data:${data.texture.mimeType};base64,${data.texture.data}`)
                    .then(res => res.arrayBuffer());
                output.innerHTML += `<span class="success">âœ… è§£ç æˆåŠŸ (${arrayBuffer.byteLength.toLocaleString()} å­—èŠ‚)</span>\n\n`;
                
                // Step 3: Load ZIP
                output.innerHTML += '3ï¸âƒ£ åŠ è½½ZIP...\n';
                const zip = await JSZip.loadAsync(arrayBuffer);
                output.innerHTML += `<span class="success">âœ… ZIPåŠ è½½æˆåŠŸ (${Object.keys(zip.files).length} ä¸ªæ–‡ä»¶)</span>\n\n`;
                
                // Step 4: Extract textures
                output.innerHTML += '4ï¸âƒ£ æå–æè´¨...\n';
                const texturePathPrefix = 'assets/minecraft/textures/blocks/';
                let textureCount = 0;
                
                zip.forEach((relativePath, zipEntry) => {
                    if (relativePath.startsWith(texturePathPrefix) && 
                        relativePath.toLowerCase().endsWith('.png') && 
                        !zipEntry.dir) {
                        textureCount++;
                    }
                });
                
                output.innerHTML += `<span class="success">âœ… æ‰¾åˆ° ${textureCount} ä¸ªæè´¨</span>\n\n`;
                
                // Success
                output.innerHTML += '='*60 + '\n';
                output.innerHTML += '<span class="success">ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼æè´¨åŒ…åŠŸèƒ½æ­£å¸¸ï¼</span>\n';
                output.innerHTML += '='*60 + '\n';
                
            } catch (error) {
                output.innerHTML += `\n<span class="error">âŒ æµ‹è¯•å¤±è´¥: ${error.message}\n${error.stack}</span>`;
            }
        }
        
        // è‡ªåŠ¨è¿è¡Œæµ‹è¯•
        window.addEventListener('load', () => {
            console.log('JSZip loaded:', typeof JSZip !== 'undefined');
            console.log('Page ready');
        });
    </script>
</body>
</html>
